# extensions of Associations.independence

using Associations
using DelimitedFiles
using Random
using TimeseriesSurrogates
import ProgressMeter
import StateSpaceSets: AbstractStateSpaceSet

# multidimensional version of RandomShuffle() surrogate
struct MultidimRandomShuffle <: Surrogate end

function TimeseriesSurrogates.surrogenerator(x::AbstractStateSpaceSet, rf::MultidimRandomShuffle, rng = Random.default_rng())
    n = length(x)
    idxs = collect(1:n)

    init = (
        permutation = collect(1:n),
    )

    return TimeseriesSurrogates.SurrogateGenerator(rf, x, similar(x.data), init, rng)
end

function (sg::TimeseriesSurrogates.SurrogateGenerator{MultidimRandomShuffle, T})() where T<:AbstractStateSpaceSet
    x, s, rng = sg.x, sg.s, sg.rng
    n = length(x)
    permutation = getfield.(Ref(sg.init), (:permutation))
    shuffle!(rng, permutation)
    for i in 1:n
        s[i] = x[permutation[i]]
    end
    return T(s)
end

# concrete implementation of independence test with surrogates generated by (multi-dimensional) random shuffle
# for TE estimators
function Associations.independence(test::SurrogateAssociationTest{<:TransferEntropyEstimator, R, MultidimRandomShuffle}, x, y) where R
    # setup
    (; est_or_measure, rng, surrogate, nshuffles, show_progress) = test
    emb = est_or_measure.definition.embedding
    emb.dS > 1 || throw(ArgumentError("dS = 1, use RandomShuffle()"))
    S, T, Tf, C = Associations.individual_marginals_te(emb, x, y)
    progress = ProgressMeter.Progress(nshuffles;
        desc="SurrogateAssociationTest:", enabled=show_progress
    )

    # estimate
    Î = association(est_or_measure, StateSpaceSet(x), StateSpaceSet(y))
    s = surrogenerator(S, surrogate, rng)
    Îs = zeros(nshuffles)
    for b in 1:nshuffles
        Îs[b] = Associations.estimate_from_marginals(est_or_measure, s(), T, Tf, C)
        ProgressMeter.next!(progress)
    end
    p = count(Î .<= Îs) / nshuffles
    return SurrogateAssociationTestResult(2, Î, Îs, p, nshuffles)
end

# concrete implementation of independence test with surrogates generated by (multi-dimensional) random shuffle
# for CMI decomposition
function Associations.independence(test::SurrogateAssociationTest{<:CMIDecomposition{<:TransferEntropy, <:FPVP}, R, MultidimRandomShuffle}, x, y) where R
    # setup
    (; est_or_measure, rng, surrogate, nshuffles, show_progress) = test
    emb = est_or_measure.definition.embedding
    emb.dS > 1 || throw(ArgumentError("dS = 1, use RandomShuffle()"))
    S, T, Tf, C = Associations.individual_marginals_te(emb, x, y)
    progress = ProgressMeter.Progress(nshuffles;
        desc="SurrogateAssociationTest:", enabled=show_progress
    )

    # estimate
    Î = association(est_or_measure, StateSpaceSet(x), StateSpaceSet(y))
    s = surrogenerator(S, surrogate, rng)
    Îs = zeros(nshuffles)
    for b in 1:nshuffles
        Îs[b] = association(FPVP(k=est_or_measure.est.k, w=est_or_measure.est.w), Tf, s(), T)
        ProgressMeter.next!(progress)
    end
    p = count(Î .<= Îs) / nshuffles
    return SurrogateAssociationTestResult(2, Î, Îs, p, nshuffles)
end

# pre-computed wavelet-based surrogate
@kwdef struct PrecomputedWLS <: Surrogate
    file::String # path to file with precomputed surrogates
end

# concrete implementation of independence test with pre-computed surrogates generated by WLS method
# for TE estimators
function Associations.independence(test::SurrogateAssociationTest{<:EntropyDecomposition{<:TransferEntropy}, R, PrecomputedWLS}, x, y) where R
    # setup
    (; est_or_measure, rng, surrogate, nshuffles, show_progress) = test
    estimation = x -> association(est_or_measure, x, y)
    progress = ProgressMeter.Progress(nshuffles;
        desc="SurrogateAssociationTest:", enabled=show_progress
    )

    # read precomputed surrogates
    x_surros = readdlm(surrogate.file)
    size(x_surros, 2) >= nshuffles || throw(DimensionMismatch("number of precomputed surrogates must be >= nshuffles"))
    size(x_surros, 1) == length(x) || throw(DimensionMismatch("length of precomputed surrogates must match length of source"))

    # estimate
    Î = estimation(StateSpaceSet(x))
    Îs = zeros(nshuffles)
    for b in 1:nshuffles
        Îs[b] = estimation(StateSpaceSet(x_surros[:, b]))
        ProgressMeter.next!(progress)
    end
    p = count(Î .<= Îs) / length(Îs)
    return SurrogateAssociationTestResult(2, Î, Îs, p, nshuffles)
end

# concrete implementation of independence test with pre-computed surrogates generated by WLS method
# for CMI decomposition
function Associations.independence(test::SurrogateAssociationTest{<:CMIDecomposition{<:TransferEntropy, <:FPVP}, R, PrecomputedWLS}, x, y) where R
    # setup
    (; est_or_measure, rng, surrogate, nshuffles, show_progress) = test
    estimation = x -> association(est_or_measure, x, StateSpaceSet(y))
    progress = ProgressMeter.Progress(nshuffles;
        desc="SurrogateAssociationTest:", enabled=show_progress
    )

    # read precomputed surrogates
    x_surros = readdlm(surrogate.file)
    size(x_surros, 2) >= nshuffles || throw(DimensionMismatch("number of precomputed surrogates must be >= nshuffles"))
    size(x_surros, 1) == length(x) || throw(DimensionMismatch("length of precomputed surrogates must match length of source"))

    # estimate
    Î = estimation(StateSpaceSet(x))
    Îs = zeros(nshuffles)
    for b in 1:nshuffles
        Îs[b] = estimation(StateSpaceSet(x_surros[:, b] .+ 1e-15randn(length(x)))) # add a little noise for numerical stability
        ProgressMeter.next!(progress)
    end
    p = count(Î .<= Îs) / nshuffles
    return SurrogateAssociationTestResult(2, Î, Îs, p, nshuffles)
end

# extension of independence tests with EntropyDecomposition estimators
function Associations.independence(test::SurrogateAssociationTest{<:EntropyDecomposition{<:TransferEntropy}, R, <:Union{WLS, BlockShuffle}}, x, y) where R
    # setup
    (; est_or_measure, rng, surrogate, nshuffles, show_progress) = test
    estimation = x -> association(est_or_measure, x, StateSpaceSet(y))
    progress = ProgressMeter.Progress(nshuffles;
        desc="SurrogateAssociationTest:", enabled=show_progress
    )

    # initialize surrogate generator
    s = surrogenerator(x, surrogate, rng)

    # estimate
    Î = estimation(StateSpaceSet(x))
    Îs = zeros(nshuffles)
    for b in 1:nshuffles
        Îs[b] = estimation(s())
        ProgressMeter.next!(progress)
    end
    p = count(Î .<= Îs) / nshuffles
    return SurrogateAssociationTestResult(2, Î, Îs, p, nshuffles)
end